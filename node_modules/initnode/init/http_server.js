/*********************************************************************************
 * InitNode 1.0 nodejs框架 
 * 文件说明：web服务器运行实例，主要功能是创建http服务器 
 *-------------------------------------------------------------------------------
 * 版权所有: CopyRight By initphp.com
 * 您可以自由使用该源码，但是在使用过程中，请保留作者信息。尊重他人劳动成果就是尊重自己
 *-------------------------------------------------------------------------------
 * $Author:zhuli
 * $Dtime:2012-9-9
***********************************************************************************/
var http_server = function () {

	var _this 			= this;
	var initnode 		= {};	//initnode对象结构，存放框架提供的初始化对象
	initnode.instance 	= {}; //单例容器
	var http 			= require("http"); //http服务器
	var path = {		//框架目录结构
		'init': '.',
		'library': '../library',
	};

	/*	
	 *	启动HTTP服务器 并且运行框架
	 */
	this.start = function () {
		initnode.core = initnode.load('core', 'init'); //加载核心
		var configObj = require('../config');//加载配置文件
		initnode.config = configObj.config; //配置类
		var listen 	= initnode.config.server.listen;
		var processLen = initnode.config.server.process;

		if (processLen > 1) { 
			//多进程 主进程实现TCP，将handle发送给子进程
			if (process.argv[2] == 'process') {
				var indexFile = initnode.config.base.indexFile;
				var child_process = require('child_process');
				var net = require("net");
				var tcp = net.createServer();
				tcp.listen(listen , function() {
					console.log('fork process start');
					console.log('listen:' + listen);
					for (var i = 0; i < processLen; i++) {
						start_process(child_process, tcp, indexFile); //启动进程
					}
					console.log('fork process end\r\n');
					tcp.close();
				});
			} else {
				//子进程接收主进程handle
				process.on("message",function(m, handle) { 
					http.createServer(_this.on).listen(handle);//运行HTTP服务器	
				});
			}
		} else {
			http.createServer(_this.on).listen(listen);//运行HTTP服务器	
		}
		console.log("Http Server is Start, Pid:" + process.pid);
	};

	/*	
	 *	框架运行核心
	 */
	this.on = function (req, res) {
		initnode.req 		= req;	//request数据
		initnode.res 		= res;	//response数据
		initnode.postData 	= '';
		initnode.response = initnode.load('response', 'init');
		initnode.response.init(initnode);
		
		initnode.req.on('data', function (postDataChunk) {
			initnode.postData += postDataChunk;
		});
		initnode.req.on('end', function() {	
			try { //异常捕获
				initnode.core.init(initnode);
			} catch (err) {
				console.log(err);
				initnode.error(err);
			}
		});
	};
	
	/*	
	 *	系统错误
	 *	参数：
	 *	err ： 错误对象
	 *	使用：
	 *	加载本地模块 initnode.error('request')
	 */
	initnode.error = function (err) {
		initnode.log = initnode.load('log', 'init');
		var path = initnode.config.base.error_log;
		var myDate = new Date();
		log_info	=	'';
		log_info 	+=  myDate.getFullYear() + '-' + myDate.getMonth() + '-' + myDate.getDate() +' ';
		log_info 	+=  myDate.toLocaleTimeString() + ' ';
		log_info	+=	err;
		initnode.log.write(path, log_info + '\r\n'); //写入错误日志
		if (initnode.config.base.de_bug == true) {
			initnode.response.sendHtml(err.toString()); //输出到页面
		} else {
			initnode.response.send500(); //返回500错误
		}
	};
	
	/*	
	 *	load加载函数，单例模式
	 *	参数：
	 *	name ： 加载模块名称
	 *	_path: 	加载模块路劲标识，对应path变量，例如init,core,library
	 *	使用：
	 *	加载本地模块 initnode.load('request', 'init')
	 *	加载系统模块 initnode.load('http')
	 */
	initnode.load = function (name, _path) {
		if (_path == undefined) {
			return initnode.reload(name, _path);
		}
		var instanceName = _path + '_' + name;
		if (initnode.instance[instanceName]) {
			return initnode.instance[instanceName];
		} else {
			return initnode.reload(name, _path);
		}
	};

	/*	
	 *	reload重新加载函数，可以实现多次实例化
	 *	参数：
	 *	name ： 加载模块名称
	 *	_path: 	加载模块路劲标识，对应path变量，例如init,core,library
	 *	使用：
	 *	加载本地模块 initnode.reload('request', 'init')
	 *	加载系统模块 initnode.reload('http')
	 */
	initnode.reload = function (name, _path) {
		var instanceName = _path + '_' + name;
		if (_path == undefined) {
			_path = '';
			return require(name);
		} else {
			var filename = path[_path] + '/' + name;
			var tempObj = require(filename);
			initnode.instance[instanceName] = new tempObj;
			return initnode.instance[instanceName]
		}
	};

	/*	
	 *	实现进程启动，并且监控进程，如果进程退出，自动调用该函数重新启动
	 */
	var start_process = function (child_process, tcp, indexFile) {
		var cp = child_process.fork(indexFile);
		cp.send('yes', tcp._handle);
		console.log('pid:' + cp.pid);
		cp.on('exit', function () {
			start_process(child_process, tcp, indexFile);
		});
	}

}

module.exports = http_server;